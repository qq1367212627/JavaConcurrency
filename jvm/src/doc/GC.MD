#GC
## 垃圾收集算法

### 引用计数法
* 思想：在被其他对象引用的时候引用计数器+1，引用失效时引用计数器-1。引用为0对象被回收。
* 算法弊端：无法处理循环引用的场景（递归对一个对象引用多次）

###  标记清除算法
* 思想：对没有引用的对象进行标记，GC进行的时候，若发现对象被标记则进行回收
* 算法弊端：由于对象的在内存中是随机分部，回收之后会产生内存碎片。

### 复制算法（新生代）对象存活时间短
* 思想：将内存分为2块，每次使用其中一块，GC进行时将含有引用的对象复制到未使用的那片内存区，然后垃圾收集器回收当前使用的内存区。如此反复的复制被引用的对象，清除无引用的对象被称为复制算法。（Java中的中S0内存区和S1内存区则是使用这种思想。）

### 标记压缩法（老年代）对象存活时间长
* 老年代比较稳定，对象存活时间长，标记压缩法在标记清除法上做了优化，将存活的对象压缩到内存一侧，然后清除无用对象。

### 分代算法：根据对象的特点，把内存分为老年代和新生代

### 分区算法（G1）：将内存区划分为多个小的分区，GC进行时，可以对每个小的分区回收，减少GC时的停顿时间。

